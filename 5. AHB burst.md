# BURST OPERATION IN AHB PROTOCOL
Burst in AHB are of 4, 8, 16 beats, undefined bursts and single transfers are defined in this protocol. It supports incrementing and wrapping bursts.  
Burst= sending more than one data packet in  a single transaction between a master and slave  
Beat= number of packets in a burst :  
⦁	4beat= 4 packets;  
⦁	8beat= 8 packets;  
⦁	16 beat= 16 packets  

<img width="775" height="546" alt="Screenshot 2025-11-17 080347" src="https://github.com/user-attachments/assets/b179efdf-21d6-44cb-aaf6-7c29cde9ae73" />

##  Bursts are of 2 types: 
### 1.	<b> Incremental bursts: </b>
Incrementing bursts access sequential locations and address of each transfer in the burst is an increment of the previous address. In incremental burst type we are allocating addresses until we meet our address boundary.  Managers must not attempt to start an incrementing burst that crosses a 1KB address boundary. 
Managers can perform single transfers using either:  
a.	Single transfer burst    
b.	Undefined length burst that has a burst of length one    
#### Eg1:
1.	 Let the starting address is 0x00
2.	 Let HSIZE= 3’b000 means size of data=1byte = 8bits
3.	 if type is INCR4 , where 4 indicates number of beats in a packet
4.	 2nd packet address= 0x01
5.	 3rd packet address = 0x02
6.	 4th packet address = 0x03
#### Eg2:
1.  Let the starting address is 0x00
2.  Let HSIZE= 3’b001 means size of data=2bytes= 16 bits
3.  if type is INCR4 , where 4 indicates number of beats in a packet
4.  2nd packet address= 0x02
5.  3rd packet address = 0x04
6.  4th packet address = 0x06
   
### 2. <b> Wrapping bursts: </b>
Wrapping bursts wrap when they cross an address boundary. The address boundary is calculated as the product of the number os beats in a burst and the size of the transfer. The number of beats are controlled by the HBURST and the transfer size is controlled by the HSIZE. 

Eg: a 4 beat wrapping burst of word (4 byte) accessess wraps at 16 byte boundaries. Therefore, if the start address of the burst is 0x34, then it contains of 4 transfers to addresses 0x34. 0x38, 0x3c and 0x30

Wrapping burst we will wrap back to the initial/start address after reaching the address boundary. Here address bound is calculated by :  
<b> ADDRESS BOUND= HSIZE * HBURST </b>

Eg: If HSIZE= 3’b000 = 1 byte and if HBURST= 3’b010 = WRAP4= 4 beat wrapping burst   
Then address boundary= 4 byte  

<img width="1912" height="908" alt="Screenshot 2025-11-17 081719" src="https://github.com/user-attachments/assets/2ebe7ae4-9183-4834-a6fa-30b69e7a8441" />

## 1.	Four beat incrementing burst INCR4

<img width="1664" height="872" alt="Screenshot 2025-11-17 082009" src="https://github.com/user-attachments/assets/f16e2ac9-3cbb-41df-a1fa-f5f79ff4c2f6" />

1. T0-T1: address phase of P1: HTRANS= NONSEQ, HADDR=0X38, HWRITE=0(read operation), HBURST=INCR4, HSIZE=word (32 bits= 4 bytes), HREADY=1, HRDATA=XX
2. T1-T2: data phase of P1: HWRITE=0(read operation), HREADY=0, HRDATA=XX
3. T1-T2: address phase of P2: HTRANS= SEQ, HADDR=0X38+4=0X3C, HBURST=INCR4, HSIZE=word (32 bits= 4 bytes)
4. T2-T3: extended data phase of P1: HWRITE=0(read operation), HREADY=1, HRDATA=data(0x38)
5. T2-T3: extended address phase of P2: HTRANS= SEQ, HADDR=0X38+4=0X3C, HBURST=INCR4, HSIZE=word (32 bits= 4 bytes)
6. T3-T4: data phase of P2: HWRITE=0(read operation), HREADY=1, HRDATA=data(0x3C)
7. T3-T4: address phase of P3: HTRANS= SEQ, HADDR=0X3C+4=0X40, HBURST=INCR4, HSIZE=word (32 bits= 4 bytes)
8. T4-T5: data phase of P3: HWRITE=0(read operation), HREADY=1, HRDATA=data(0x40)
9. T4-T5: address phase of P4: HTRANS= SEQ, HADDR=0X40+4=0X44, HBURST=INCR4, HSIZE=word (32 bits= 4 bytes)
10. T5-T6: data phase of P4: HWRITE=0(read operation), HREADY=1, HRDATA=data(0x44)


## 2.	Four beat wrapping burst WRAP4

<img width="1661" height="848" alt="image" src="https://github.com/user-attachments/assets/90faa993-9501-42d4-9790-4dc919e36de0" />

1. T0-T1: address phase of P1: HTRANS= NONSEQ, HADDR=0X38, HWRITE=0(read operation), HBURST=WRAP4, HSIZE=word (32 bits= 4 bytes), HREADY=1, HRDATA=XX
2. T1-T2: data phase of P1: HWRITE=0(read operation), HREADY=0, HRDATA=XX
3. T1-T2: address phase of P2: HTRANS= SEQ, HADDR=0X38+4=0X3C, HBURST=WRAP4, HSIZE=word (32 bits= 4 bytes)
4. T2-T3: extended data phase of P1: HWRITE=0(read operation), HREADY=1, HRDATA=data(0x38)
5. T2-T3: extended address phase of P2: HTRANS= SEQ, HADDR=0X38+4=0X3C, HBURST=WRAP4, HSIZE=word (32 bits= 4 bytes) 
6. T3-T4: data phase of P2: HWRITE=0(read operation), HREADY=1, HRDATA=data(0x3C)
7. T3-T4: address phase of P3: HTRANS= SEQ, HADDR=0X3C+4=0X30, HBURST=WRAP4, HSIZE=word (32 bits= 4 bytes) *CHANGED*
8. T4-T5: data phase of P3: HWRITE=0(read operation), HREADY=1, HRDATA=data(0x30)
9. T4-T5: address phase of P4: HTRANS= SEQ, HADDR=0X30+4=0X34, HBURST=WRAP4, HSIZE=word (32 bits= 4 bytes) *CHANGED*
10. T5-T6: data phase of P4: HWRITE=0(read operation), HREADY=1, HRDATA=data(0x34)

CALCULATION: address boundary= HSIZE * HBURST= 4 bytes * 4 = 16 bytes  
starting address in AHB protocol must always be an *aligned address*. meaning start address must always be an even number eg: 0x30, 0x32, 0x34 and so on. unaligned address means starting with odd number eg: 0x31, 0x33 or 0x35.  
1. eg:   
   If HBURST= WRAP4, HSIZE=000= 1byte, Address boundary= 4 byte.    
   1st boundary will include : 0x00, 0x01,0x02, 0x03  : 4 bytes of a burst including 4 packets of 1 byte each   
   2nd boundary will include : 0x04, 0x05, 0x06, 0x07   
   3rd boundary will include: 0x08,0x09, 0x0A, 0x0B   
   4th boundary will include: 0x0C, 0x0D, 0x0E, 0x0F  ... and so on   
   case1: starting address is 0x00: then the rest packets will be 0x01, 0x02, 0x03   
   case2: starting address is 0x02: then the rest packets will be 0x03, 0x00, 0x01    
   due to wrap4 type of burst once the address bound is reached, address is wrapped to starting address    

2. eg:   
   HBURST= WRAP4, HSIZE=001= 2bytes, HWRITE=1, Address boundary= 8 bytes  
   1st boundary will include : 0x00, 0x02, 0x04, 0x06 : each data packet is of 2 bytes  : 8 bytes of a burst address including 4 packets of 2 byte each  
   2nd boundary will include : 0x08, 0x0A, 0x0C, 0x0E  
   3rd boundary will include : 0x10, 0x12, 0x14, 0x16  
   4th boundary will include : 0x18, 0x1A, 0x1C, 0x1E.... and so on  
   case1: starting address is 0x10: then the rest packets will be 0x12, 0x14, 0x16    
   case2: starting address is 0x24: then the rest packets will be 0x26, 0x00, 0x02: the packets should not go into the next boundary     


3. eg:    
   HBURST= WRAP4, HSIZE=010= 4bytes, HWRITE=1, Address boundary= 16 bytes    
   1st boundary will include : 0x00, 0x04, 0x08, 0x0C : each data packet is of 4 bytes  : 16 bytes of a burst address including 4 packets of 4 byte each    
   2nd boundary will include : 0x10, 0x14, 0x18, 0x1C    
   3rd boundary will include : 0x20, 0x24, 0x28, 0x2C   
   4th boundary will include : 0x30, 0x34, 0x28, 0x2C.... and so on   
   case1: starting address is 0x10: then the rest packets will be 0x14, 0x18, 0x1C   
   case2: starting address is 0x24: then the rest packets will be 0x28, 0x2C  0x20: the packets should not go into the next boundary   
   
## 3.	Eight beat wrapping burst WRAP8

<img width="1808" height="891" alt="image" src="https://github.com/user-attachments/assets/f8860932-c84f-4ba5-9071-107c7df5aeae" />

WRAP8, HSIZE= word = 4 byte, address boundary = 32 byte  
here the boundary is: 0X20, 0x24, 0x28, 0x2C, 0x30, 0x34, 0x3C  
hence in the address we see that after the boundary is exceeded in WRAP4, the address is returned to start

## 4. Eight beat INCREMENTAL burst INCR8

<img width="1815" height="894" alt="image" src="https://github.com/user-attachments/assets/c00e302e-c1bd-41d2-ab57-853e5b39a7ee" />

## 5. Undefined length bursts, INCR

<img width="1869" height="1014" alt="image" src="https://github.com/user-attachments/assets/ca71b039-847b-49b7-a719-69f60fda4201" />

length is unknown: slave dont know how many beats the master is going to send. 
the completeion of a burst transfer is indicated by HTRANS value
1. T0-T1: address of P1: HTRANS=NONSEQ (first data packet is transferred) HADDR-0X20 (starting address of P1), HWRITE=1 (write data), HBURST=INCR, HSIZE= halfword (2 bytes)  
2. T0-T1: HREADY=1 (master is ready to write data), HDATA=XX 
3. T1-T2: data of P1: HREADY=1 (master is ready to write data), HWDATA= data(0X20) HRDATA=XX
4. T1-T2: address of P2: HTRANS= SEQ, HADDR=0X20+2=0X22,  HWRITE=1 (write data), HBURST=INCR, HSIZE= halfword (2 bytes)  
5. T2-T3: data of P2: HREADY=1 (master is ready to write data), HWDATA= data(0X22) HRDATA=XX
6. T2-T3:  HTRANS=NONSEQ (first data packet is transferred), HADDR-0X5C (starting address of another burst P1), HWRITE=0 (read data), HBURST=INCR, HSIZE= word (4 bytes)  change of HTRANS from sequential to non sequential indicates the completion of transfer of that packet
7. T3-T4: data of P1: HREADY=0 (master is not ready to read data), HWDATA= XX HRDATA=XX
8. T3-T4: address of P2: HTRANS= SEQ, HADDR=0X5C+4=0X60,  HWRITE=0 (read data), HBURST=INCR, HSIZE= word (4 bytes)
9. T4-T5: extended data of P1: HREADY=1 (master is ready to read data), HWDATA= XX HRDATA=data(0x5C)
10. T4-T5: extended address of P2: HTRANS= SEQ, HADDR=0X5C+4=0X60,  HWRITE=0 (read data), HBURST=INCR, HSIZE= word (4 bytes)
11. T5-T6: data of P2: HREADY=1 (master is ready to read data), HWDATA= XX HRDATA=data(0x60)
12. T5-T6: address of P2: HTRANS= SEQ, HADDR=0X60+4=0X64,  HWRITE=0 (read data), HBURST=INCR, HSIZE= word (4 bytes)
13. T6-T7: data of P3: HREADY=1 (master is ready to read data), HWDATA= XX HRDATA=data(0x64)
